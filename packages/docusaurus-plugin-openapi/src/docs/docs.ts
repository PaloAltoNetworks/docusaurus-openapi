/* ============================================================================
 * Copyright (c) Cloud Annotations
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 * ========================================================================== */

import path from "path";

import type {
  CategoryIndexMatcher,
  CategoryIndexMatcherParam,
} from "@docusaurus/plugin-content-docs";
import {
  aliasedSitePath,
  parseMarkdownString,
  normalizeUrl,
} from "@docusaurus/utils";
import fs from "fs-extra";

import { DocPageMetadata } from "../types";
import { validateDocFrontMatter } from "./docFrontmatter";
import { DocObject, DocMetadataBase } from "./types";

interface DocFiles {
  source: string;
  sourceDirName: string;
  data: DocObject;
}

// By convention, Docusaurus considers some docs are "indexes":
// - index.md
// - readme.md
// - <folder>/<folder>.md
//
// This function is the default implementation of this convention
//
// Those index docs produce a different behavior
// - Slugs do not end with a weird "/index" suffix
// - Auto-generated sidebar categories link to them as intro
export const isCategoryIndex: CategoryIndexMatcher = ({
  fileName,
  directories,
}): boolean => {
  const eligibleDocIndexNames = [
    "index",
    "readme",
    directories[0]?.toLowerCase(),
  ];
  return eligibleDocIndexNames.includes(fileName.toLowerCase());
};

/**
 * `guides/sidebar/autogenerated.md` ->
 *   `'autogenerated', '.md', ['sidebar', 'guides']`
 */
export function toCategoryIndexMatcherParam({
  source,
  sourceDirName,
}: Pick<
  DocMetadataBase,
  "source" | "sourceDirName"
>): CategoryIndexMatcherParam {
  // source + sourceDirName are always posix-style
  return {
    fileName: path.posix.parse(source).name,
    extension: path.posix.parse(source).ext,
    directories: sourceDirName.split(path.posix.sep).reverse(),
  };
}

export async function readDocFiles(
  beforeApiDocs: Array<string>,
  _options: {}
): Promise<DocFiles[]> {
  const sources = beforeApiDocs.map(async (source) => {
    const fullPath = path.join(source);
    const data = (await fs.readFile(fullPath, "utf-8")) as DocObject;
    return {
      source: fullPath, // This will be aliased in process.
      sourceDirName: path.dirname(source),
      data,
    };
  });
  return Promise.all(sources);
}

export async function processDocFiles(
  files: DocFiles[],
  options: {
    baseUrl: string;
    routeBasePath: string;
    siteDir: string;
  }
): Promise<DocPageMetadata[]> {
  const promises = files.map(async (file) => {
    const {
      frontMatter: unsafeFrontMatter,
      contentTitle,
      excerpt,
    } = parseMarkdownString(file.data as string);
    const frontMatter = validateDocFrontMatter(unsafeFrontMatter);
    const slug = "/" + frontMatter.id;
    const permalink =
      options.baseUrl + options.routeBasePath + "/" + frontMatter.id;
    return {
      type: "doc" as "doc", // TODO: fix this
      id: frontMatter.id ?? "",
      unversionedId: frontMatter.id ?? "",
      title: frontMatter.title ?? contentTitle ?? frontMatter.id ?? "",
      description: frontMatter.description ?? excerpt ?? "",
      slug: slug,
      frontMatter: frontMatter,
      permalink: permalink,
      ...file,
      source: aliasedSitePath(file.source, options.siteDir),
      sourceDirName: file.sourceDirName,
    } as DocPageMetadata;
  });
  const metadata = await Promise.all(promises);
  const items = metadata.flat();

  let seen: { [key: string]: number } = {};
  for (let i = 0; i < items.length; i++) {
    const baseId = items[i].id;
    let count = seen[baseId];

    let id;
    if (count) {
      id = `${baseId}-${count}`;
      seen[baseId] = count + 1;
    } else {
      id = baseId;
      seen[baseId] = 1;
    }

    items[i].id = id;
    items[i].unversionedId = id;
    items[i].slug = "/" + id;
  }

  for (let i = 0; i < items.length; i++) {
    const current = items[i];
    const prev = items[i - 1];
    const next = items[i + 1];

    current.permalink = normalizeUrl([
      options.baseUrl,
      options.routeBasePath,
      current.id,
    ]);

    if (prev) {
      current.previous = {
        title:
          (prev.frontMatter.pagination_label as string) ??
          (prev.frontMatter.sidebar_label as string) ??
          prev.title,
        permalink: normalizeUrl([
          options.baseUrl,
          options.routeBasePath,
          prev.id,
        ]),
      };
    }

    if (next) {
      current.next = {
        title:
          (next.frontMatter.pagination_label as string) ??
          (next.frontMatter.sidebar_label as string) ??
          next.title,
        permalink: normalizeUrl([
          options.baseUrl,
          options.routeBasePath,
          next.id,
        ]),
      };
    }
  }

  return items;
}
